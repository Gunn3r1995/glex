\hypertarget{classCubeAsset}{}\section{Cube\+Asset Class Reference}
\label{classCubeAsset}\index{Cube\+Asset@{Cube\+Asset}}


{\ttfamily \#include $<$Cube\+Asset.\+h$>$}



Inheritance diagram for Cube\+Asset\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classCubeAsset__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Cube\+Asset\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classCubeAsset__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classCubeAsset_a0252e564114a3cda7e3911ef95742a34}{Cube\+Asset} (G\+Lfloat x, G\+Lfloat y, G\+Lfloat z)
\item 
\hyperlink{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}{$\sim$\+Cube\+Asset} ()
\item 
virtual void \hyperlink{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}{Draw} (G\+Luint)
\item 
void \hyperlink{classCubeAsset_ac3855728a8d6c1612ebc85f82d3b535e}{check\+Error} (std\+::string file, int line)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classCubeAsset_a0252e564114a3cda7e3911ef95742a34}{}\index{Cube\+Asset@{Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\index{Cube\+Asset@{Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{Cube\+Asset(\+G\+Lfloat x, G\+Lfloat y, G\+Lfloat z)}]{\setlength{\rightskip}{0pt plus 5cm}Cube\+Asset\+::\+Cube\+Asset (
\begin{DoxyParamCaption}
\item[{G\+Lfloat}]{x, }
\item[{G\+Lfloat}]{y, }
\item[{G\+Lfloat}]{z}
\end{DoxyParamCaption}
)}\label{classCubeAsset_a0252e564114a3cda7e3911ef95742a34}
Sets cordinates to a cube with the center point 0.\+0 but moved to where the x, y, z variables calls them from the gameworld class through the G\+Lfloat x,y,z variables

Colour of Cube Asset Saddle Brown Uses R\+G\+B values to set the colour

Draws the cube voxel up of 12 Triangles Two Triangles per Face
\begin{DoxyCode}
5                                                      \{
6   \textcolor{comment}{// model coordinates, origin at centre.}
12 \textcolor{comment}{}  GLfloat vertex\_buffer [] \{
13       0.5f + x  , 0.5f + y  , -0.5f + z
14     , 0.5f + x  ,-0.5f + y  , -0.5f + z
15     ,-0.5f + x  , 0.5f + y  , -0.5f + z
16     ,-0.5f + x  ,-0.5f + y  , -0.5f + z
17     , 0.5f + x  , 0.5f + y  ,  0.5f + z 
18     , 0.5f + x  ,-0.5f + y  ,  0.5f + z
19     ,-0.5f + x  , 0.5f + y  ,  0.5f + z
20     ,-0.5f + x  ,-0.5f + y  ,  0.5f + z
21   \};
22   GLfloat vertex\_buffer\_length = \textcolor{keyword}{sizeof}(vertex\_buffer);
27   GLfloat colour\_buffer[] = \{
28 
29      0.139f, 0.069f, 0.019f,
30      0.139f, 0.069f, 0.019f,
31      0.139f, 0.069f, 0.019f,
32      0.139f, 0.069f, 0.019f,
33      0.139f, 0.069f, 0.019f,
34      0.139f, 0.069f, 0.019f,
35      0.139f, 0.069f, 0.019f,
36      0.139f, 0.069f, 0.019f
37   \};
38   colour\_buffer\_length = \textcolor{keyword}{sizeof}(colour\_buffer);
43   GLuint element\_buffer []  \{
44       0, 1, 2   
45     , 1, 3, 2
46     , 0, 4, 1   
47     , 1, 5, 4   
48     , 5, 7, 4   
49     , 7, 6, 4   
50     , 3, 7, 6   
51     , 2, 3, 6   
52     , 1, 5, 7   
53     , 1, 3, 7   
54     , 0, 4, 6   
55     , 0, 2, 6   
56   \};
57   element\_buffer\_length = \textcolor{keyword}{sizeof}(element\_buffer);
58 
59 
60 
61   \textcolor{comment}{// Transfer buffers to the GPU}
62 
63   \textcolor{comment}{// create buffer}
64   glGenBuffers(1, &vertex\_buffer\_token);
65   \textcolor{comment}{// immediately bind the buffer and transfer the data}
66   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
67   glBufferData(GL\_ARRAY\_BUFFER, vertex\_buffer\_length, vertex\_buffer, GL\_STATIC\_DRAW);
68   
69   \textcolor{comment}{// Binds the buffer to transfer the data}
70   glGenBuffers(1, &colour\_buffer\_token);
71   glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
72   glBufferData(GL\_ARRAY\_BUFFER, colour\_buffer\_length, colour\_buffer, GL\_STATIC\_DRAW);
73 
74 
75   glGenBuffers(1, &element\_buffer\_token);
76   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
77   glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_length, element\_buffer, GL\_STATIC\_DRAW);
78 \}
\end{DoxyCode}
\hypertarget{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}{}\index{Cube\+Asset@{Cube\+Asset}!````~Cube\+Asset@{$\sim$\+Cube\+Asset}}
\index{````~Cube\+Asset@{$\sim$\+Cube\+Asset}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{$\sim$\+Cube\+Asset()}]{\setlength{\rightskip}{0pt plus 5cm}Cube\+Asset\+::$\sim$\+Cube\+Asset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classCubeAsset_ab3ab9a5da82cbf8537a28652410093b1}

\begin{DoxyCode}
80                       \{
81 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classCubeAsset_ac3855728a8d6c1612ebc85f82d3b535e}{}\index{Cube\+Asset@{Cube\+Asset}!check\+Error@{check\+Error}}
\index{check\+Error@{check\+Error}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{check\+Error(std\+::string file, int line)}]{\setlength{\rightskip}{0pt plus 5cm}void Cube\+Asset\+::check\+Error (
\begin{DoxyParamCaption}
\item[{std\+::string}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)}\label{classCubeAsset_ac3855728a8d6c1612ebc85f82d3b535e}
\hypertarget{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}{}\index{Cube\+Asset@{Cube\+Asset}!Draw@{Draw}}
\index{Draw@{Draw}!Cube\+Asset@{Cube\+Asset}}
\subsubsection[{Draw(\+G\+Luint)}]{\setlength{\rightskip}{0pt plus 5cm}void Cube\+Asset\+::\+Draw (
\begin{DoxyParamCaption}
\item[{G\+Luint}]{program\+\_\+token}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classCubeAsset_a1af568486056e254ffcf98fd99947bfe}
use the previously transferred buffer as the vertex array. This way we transfer the buffer once -- at construction -- not on every frame.

Uses the Previously transferred buffer as the color array. This way We transfer the buffer once -- at constuction -- not on every frame

Implements \hyperlink{classGameAsset_a961aa51ca0a9961fc584c0b5d5431300}{Game\+Asset}.


\begin{DoxyCode}
98                                          \{
99   \textcolor{keywordflow}{if}(!glIsProgram(program\_token)) \{
100     std::cerr << \textcolor{stringliteral}{"Drawing Cube with invalid program"} << std::endl;
101     \textcolor{keywordflow}{return};
102   \}
103   GLint validation\_ok;
104   glValidateProgram(program\_token);
105   glGetProgramiv(program\_token, GL\_VALIDATE\_STATUS, &validation\_ok);
106   \textcolor{keywordflow}{if}(!validation\_ok) \{
107     GLint maxLength = 0;
108     glGetProgramiv(program\_token, GL\_INFO\_LOG\_LENGTH, &maxLength);
109 
110     \textcolor{comment}{// The maxLength includes the NULL character}
111     std::vector<char> errorLog(maxLength);
112     glGetProgramInfoLog(program\_token, maxLength, &maxLength, &errorLog[0]);
113 
114     std::cerr << \textcolor{stringliteral}{"Invalid program "} << program\_token << \textcolor{stringliteral}{" with error code "} << validation\_ok << std::endl;
115     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} c: errorLog) \{
116       std::cerr << c;
117     \}
118     exit(-1);
119   \}
120 
121   GLuint position\_attrib = glGetAttribLocation(program\_token, \textcolor{stringliteral}{"position"});
122   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
123 
124   glUseProgram(program\_token);
125   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
130   glEnableVertexAttribArray(0);
131   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
132   glVertexAttribPointer(
133     position\_attrib,        \textcolor{comment}{/* attribute */}
134     3,        \textcolor{comment}{/* size */}
135     GL\_FLOAT,   \textcolor{comment}{/* type */}
136     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
137     0,        \textcolor{comment}{/* stride */}
138     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
139   );
140   glEnableVertexAttribArray(1);
141   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
146   glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
147   glVertexAttribPointer(
148     1,        \textcolor{comment}{/* attribute */}
149     3,        \textcolor{comment}{/* size */}
150     GL\_FLOAT,   \textcolor{comment}{/* type */}
151     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
152     0,        \textcolor{comment}{/* stride */}
153     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
154   );
155   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
156 
157   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
158   glDrawElements(
159     GL\_TRIANGLES,
160     element\_buffer\_length,
161     GL\_UNSIGNED\_INT,
162     (GLvoid*) 0
163   );
164   \hyperlink{CubeAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
165 
166   glDisableVertexAttribArray(position\_attrib);
167 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{CubeAsset_8h}{Cube\+Asset.\+h}\item 
src/\hyperlink{CubeAsset_8cc}{Cube\+Asset.\+cc}\end{DoxyCompactItemize}
