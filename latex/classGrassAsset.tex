\hypertarget{classGrassAsset}{}\section{Grass\+Asset Class Reference}
\label{classGrassAsset}\index{Grass\+Asset@{Grass\+Asset}}


{\ttfamily \#include $<$Grass\+Asset.\+h$>$}



Inheritance diagram for Grass\+Asset\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classGrassAsset__inherit__graph}
\end{center}
\end{figure}


Collaboration diagram for Grass\+Asset\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=148pt]{classGrassAsset__coll__graph}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classGrassAsset_a961ec7133a9fc6f16a7347a122f95952}{Grass\+Asset} (G\+Lfloat x, G\+Lfloat y, G\+Lfloat z)
\item 
\hyperlink{classGrassAsset_a07e2206bacd2ec120f27f20e5df635b7}{$\sim$\+Grass\+Asset} ()
\item 
virtual void \hyperlink{classGrassAsset_a0178a72c5bf2f00bcc6a240b851f3a25}{Draw} (G\+Luint)
\item 
void \hyperlink{classGrassAsset_a06cf99092ea2217df1855e2d6375396b}{check\+Error} (std\+::string file, int line)
\end{DoxyCompactItemize}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{classGrassAsset_a961ec7133a9fc6f16a7347a122f95952}{}\index{Grass\+Asset@{Grass\+Asset}!Grass\+Asset@{Grass\+Asset}}
\index{Grass\+Asset@{Grass\+Asset}!Grass\+Asset@{Grass\+Asset}}
\subsubsection[{Grass\+Asset(\+G\+Lfloat x, G\+Lfloat y, G\+Lfloat z)}]{\setlength{\rightskip}{0pt plus 5cm}Grass\+Asset\+::\+Grass\+Asset (
\begin{DoxyParamCaption}
\item[{G\+Lfloat}]{x, }
\item[{G\+Lfloat}]{y, }
\item[{G\+Lfloat}]{z}
\end{DoxyParamCaption}
)}\label{classGrassAsset_a961ec7133a9fc6f16a7347a122f95952}
model coordinates, origin at centre. Sets cordinates to a Grass/\+Pyramid with the center point 0.\+0 but moved to where the x, y, z variables calls them from the gameworld class through the G\+Lfloat x,y,z variables.

Color Buffer. Colour of Cube Asset Green Uses R\+G\+B values to set the colour.
\begin{DoxyCode}
3                                                       \{
4 
11   GLfloat vertex\_buffer [] \{
12       -0.01f + x  , 0.00f + y   ,-0.01f + z
13      , 0.01f + x  , 0.00f + y   ,-0.01f + z
14      ,-0.01f + x  , 0.00f + y   , 0.01f + z
15      , 0.01f + x  , 0.00f + y   , 0.01f + z
16      , 0.00f + x  , 0.60f + y   , 0.00f + z
17   \};
18   GLfloat vertex\_buffer\_length = \textcolor{keyword}{sizeof}(vertex\_buffer);
24   GLfloat colour\_buffer[] = \{
25 
26      0.000f, 1.000f, 0.000f,
27      0.000f, 1.000f, 0.000f,
28      0.000f, 1.000f, 0.000f,
29      0.000f, 1.000f, 0.000f,
30      0.000f, 1.000f, 0.000f
31   \};
32  colour\_buffer\_length = \textcolor{keyword}{sizeof}(colour\_buffer);
33   
34   GLuint element\_buffer []  \{
35       0, 4, 1   
36     , 1, 4, 3
37     , 2, 4, 3   
38     , 2, 4, 0
39     , 0, 2, 1
40     , 1, 2, 3
41   \};
42   element\_buffer\_length = \textcolor{keyword}{sizeof}(element\_buffer);
43 
44 
45 
46   \textcolor{comment}{// Transfer buffers to the GPU}
47 
48   \textcolor{comment}{// create buffer}
49   glGenBuffers(1, &vertex\_buffer\_token);
50   \textcolor{comment}{// immediately bind the buffer and transfer the data}
51   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
52   glBufferData(GL\_ARRAY\_BUFFER, vertex\_buffer\_length, vertex\_buffer, GL\_STATIC\_DRAW);
53 
54   \textcolor{comment}{// Binds the buffer and transfers the data}
55   glGenBuffers(1, &colour\_buffer\_token);
56   glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
57   glBufferData(GL\_ARRAY\_BUFFER, colour\_buffer\_length, colour\_buffer, GL\_STATIC\_DRAW);
58 
59 
60   glGenBuffers(1, &element\_buffer\_token);
61   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
62   glBufferData(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_length, element\_buffer, GL\_STATIC\_DRAW);
63 \}
\end{DoxyCode}
\hypertarget{classGrassAsset_a07e2206bacd2ec120f27f20e5df635b7}{}\index{Grass\+Asset@{Grass\+Asset}!````~Grass\+Asset@{$\sim$\+Grass\+Asset}}
\index{````~Grass\+Asset@{$\sim$\+Grass\+Asset}!Grass\+Asset@{Grass\+Asset}}
\subsubsection[{$\sim$\+Grass\+Asset()}]{\setlength{\rightskip}{0pt plus 5cm}Grass\+Asset\+::$\sim$\+Grass\+Asset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classGrassAsset_a07e2206bacd2ec120f27f20e5df635b7}

\begin{DoxyCode}
65                         \{
66 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{classGrassAsset_a06cf99092ea2217df1855e2d6375396b}{}\index{Grass\+Asset@{Grass\+Asset}!check\+Error@{check\+Error}}
\index{check\+Error@{check\+Error}!Grass\+Asset@{Grass\+Asset}}
\subsubsection[{check\+Error(std\+::string file, int line)}]{\setlength{\rightskip}{0pt plus 5cm}void Grass\+Asset\+::check\+Error (
\begin{DoxyParamCaption}
\item[{std\+::string}]{file, }
\item[{int}]{line}
\end{DoxyParamCaption}
)}\label{classGrassAsset_a06cf99092ea2217df1855e2d6375396b}

\begin{DoxyCode}
75                                                     \{
76   GLenum gl\_error = glGetError();
77   \textcolor{keywordflow}{if}(GL\_NO\_ERROR != gl\_error) \{
78     std::cerr << \textcolor{stringliteral}{"GL error in "} << file << \textcolor{stringliteral}{" at line "} << line << \textcolor{stringliteral}{" error: "} << gl\_error << std::endl;
79     exit(-1);
80   \}
81 \}
\end{DoxyCode}
\hypertarget{classGrassAsset_a0178a72c5bf2f00bcc6a240b851f3a25}{}\index{Grass\+Asset@{Grass\+Asset}!Draw@{Draw}}
\index{Draw@{Draw}!Grass\+Asset@{Grass\+Asset}}
\subsubsection[{Draw(\+G\+Luint)}]{\setlength{\rightskip}{0pt plus 5cm}void Grass\+Asset\+::\+Draw (
\begin{DoxyParamCaption}
\item[{G\+Luint}]{program\+\_\+token}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classGrassAsset_a0178a72c5bf2f00bcc6a240b851f3a25}
use the previously transferred buffer as the vertex array. This way we transfer the buffer once -- at construction -- not on every frame.

Uses the Previously transferred buffer as the color array. This way We transfer the buffer once -- at constuction -- not on every frame

Implements \hyperlink{classGameAsset_a961aa51ca0a9961fc584c0b5d5431300}{Game\+Asset}.


\begin{DoxyCode}
83                                           \{
84   \textcolor{keywordflow}{if}(!glIsProgram(program\_token)) \{
85     std::cerr << \textcolor{stringliteral}{"Drawing Grass with invalid program"} << std::endl;
86     \textcolor{keywordflow}{return};
87   \}
88   GLint validation\_ok;
89   glValidateProgram(program\_token);
90   glGetProgramiv(program\_token, GL\_VALIDATE\_STATUS, &validation\_ok);
91   \textcolor{keywordflow}{if}(!validation\_ok) \{
92     GLint maxLength = 0;
93     glGetProgramiv(program\_token, GL\_INFO\_LOG\_LENGTH, &maxLength);
94 
95     \textcolor{comment}{// The maxLength includes the NULL character}
96     std::vector<char> errorLog(maxLength);
97     glGetProgramInfoLog(program\_token, maxLength, &maxLength, &errorLog[0]);
98 
99     std::cerr << \textcolor{stringliteral}{"Invalid program "} << program\_token << \textcolor{stringliteral}{" with error code "} << validation\_ok << std::endl;
100     \textcolor{keywordflow}{for}(\textcolor{keyword}{auto} c: errorLog) \{
101       std::cerr << c;
102     \}
103     exit(-1);
104   \}
105 
106   GLuint position\_attrib = glGetAttribLocation(program\_token, \textcolor{stringliteral}{"position"});
107   \hyperlink{GrassAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
108 
109   glUseProgram(program\_token);
110   \hyperlink{GrassAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
115   glEnableVertexAttribArray(0);
116   glBindBuffer(GL\_ARRAY\_BUFFER, vertex\_buffer\_token);
117   glVertexAttribPointer(
118     position\_attrib,        \textcolor{comment}{/* attribute */}
119     3,        \textcolor{comment}{/* size */}
120     GL\_FLOAT,   \textcolor{comment}{/* type */}
121     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
122     0,        \textcolor{comment}{/* stride */}
123     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
124   );
125   glEnableVertexAttribArray(1);
126   \hyperlink{GrassAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
131   glBindBuffer(GL\_ARRAY\_BUFFER, colour\_buffer\_token);
132   glVertexAttribPointer(
133     1,        \textcolor{comment}{/* attribute */}
134     3,        \textcolor{comment}{/* size */}
135     GL\_FLOAT,   \textcolor{comment}{/* type */}
136     GL\_FALSE,   \textcolor{comment}{/* normalized? */}
137     0,        \textcolor{comment}{/* stride */}
138     (\textcolor{keywordtype}{void}*)0    \textcolor{comment}{/* array buffer offset */}
139   );
140   \hyperlink{GrassAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
141 
142   glBindBuffer(GL\_ELEMENT\_ARRAY\_BUFFER, element\_buffer\_token);
143   glDrawElements(
144     GL\_TRIANGLES,
145     element\_buffer\_length,
146     GL\_UNSIGNED\_INT,
147     (GLvoid*) 0
148   );
149   \hyperlink{GrassAsset_8cc_a75f201b0e53e68726854997957322b8d}{checkGLError}();
150 
151   glDisableVertexAttribArray(position\_attrib);
152 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
src/\hyperlink{GrassAsset_8h}{Grass\+Asset.\+h}\item 
src/\hyperlink{GrassAsset_8cc}{Grass\+Asset.\+cc}\end{DoxyCompactItemize}
